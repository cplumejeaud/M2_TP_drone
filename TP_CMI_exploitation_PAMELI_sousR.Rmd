---
title: "TP CMI 2021 - exploitation de sortie 25 février 2021"
author: "C. Plumejeaud-Perreau"
date: "03/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Configure your environment

```{r config, message=FALSE, warning=FALSE}
#setwd("~/R/TP_CMI")
setwd("C:/Travail/CNRS_mycore/PAMELI/Scripts/")
getwd()

# Ajouter meslibrairiesR dans ces chemins : 
meslibrairiesR <- "C:/Tools/R4"
.libPaths(c( .libPaths(), meslibrairiesR) )

#install.packages("tidyverse")
## Charger les libraries
library(tidyverse)
library(lubridate)

#Pour les correlations
library(corrplot)
library(texreg)
library(Hmisc)

## Carto
library(sf)
library(cartography)
library(sp) #pour bbox
library(tmap)

## Markdown
library(knitr)
library(rmarkdown)
library(markdown)
```

## Lire les données

```{r read, message=FALSE, warning=FALSE}
data <- read.csv("aytre_25fev2021_ysiexo2_gps.csv", header=TRUE, sep=";", dec=",", stringsAsFactors=FALSE, encoding = "UTF-8")
```


Notez que les types des variables ne sont pas reconnus
```{r}
summary(data)
```

point_id devrait être un entier, mais il est lu comme une chaîne de caractères 
"75 177" au lieu de 75177

```{r, message=FALSE, warning=FALSE}
res <- vector("integer", length(data$point_id))
for (k in 1:length(data$point_id)){
  res[k] <- as.integer(gsub("[^0-9]", "", data$point_id[k])) 
}
data$point_id <-res
```

Utiliser mutate de tidyverse pour convertir les variables dans leur bon type
```{r, message=FALSE, warning=FALSE}
data <- data %>%
  mutate_at(vars(sensor_name, property_name, unit_code, unit_name), list(as.factor))  %>%
  mutate_at(vars(property_value, pt_longitude, pt_latitude), list(as.numeric)) %>%
  mutate_at(vars(is_reference), list(as.logical)) 
```

Process time and spatial dimension
```{r, message=FALSE, warning=FALSE}
data <- data %>% 
  mutate(date = ymd(data$date)) %>% 
  mutate(local_time = as_datetime(data$local_time))%>% 
  mutate(geom_point = st_as_sfc(data$geom_point)) 
```

Convert data to a spatial dataframe
R uses Simple Features (sf) , read https://r-spatial.github.io/sf/articles/sf1.html
```{r, message=FALSE, warning=FALSE}
datasf <- st_as_sf(data)
datasf <- st_set_crs(datasf, 4326)
```

Vérifier
```{r}
data[1,]$local_time #"2021-02-25 13:58:01 UTC"

data[1,]$date #"2021-02-25" ymd

summary(datasf)
```

## Une carte toute simple avec cartography

Emprise de la sortie, trait de cote, et trajectoire du drone

### 1. Lecture du fond de carte

```{r, message=FALSE, warning=FALSE}
getwd() #Vérifier votre répertoire de travail


library("sf")
library("cartography")
```

- Cadre
```{r, message=FALSE, warning=FALSE}
footprint<-st_read(dsn="shp/emprise_Aytre_17092020_4326.shp", stringsAsFactors = FALSE)
```
- Cote
```{r, message=FALSE, warning=FALSE}
cote<-st_read(dsn="shp/cote_GSHHS_f_L1_4326.shp", stringsAsFactors = FALSE)
cote_precise<-st_read(dsn="shp/cote_precise_line_4326.shp", stringsAsFactors = FALSE)
```
- Trajectoire du drone (simplifiée)
```{r, message=FALSE, warning=FALSE}
drone_path<-st_read(dsn="shp/curve_Aytre_25022021_4326.shp", stringsAsFactors = FALSE)
```
- 20 points d'échantillonage théorique
```{r, message=FALSE, warning=FALSE}
sampling<-st_read(dsn="geojson/sampling_4326.geojson", stringsAsFactors = FALSE)
colnames(sampling)
```


### 2. Dessin de la carte

Les couches et styles cartographiques s'empilent les uns sur les autres dans l'ordre d'appel comme dans un SIG classique


Refaire le graphique avec des marges réduites. Réduire la largeur des marges avec par(mar=()) : c(bas, gauche, haut, droite)

- OMA : augmenter la largeur de la MARGE EXTERNE (oma) sur les bords gauche et droit de 1

- MAR : reduire la largeur de la MARGE INTERNE (mar), sauf en haut ( + 1.5)

```{r, message=FALSE, warning=FALSE}
dev.off()
par(mar = c(0.5,0,1.5,0), oma = c(0,7,0,7))
```


La carte basique avec les polygones, le cartouche, la légende, l'échelle, etc.
```{r, message=FALSE, warning=FALSE}
plot(st_geometry(footprint), col="lightblue", lwd=1)
plot(st_geometry(cote), col="#93C572", add=T)
plot(st_geometry(cote_precise), col="#006400", add=T)

plot(st_geometry(drone_path), col="black", add=T, lwd=2)
plot(st_geometry(sampling), col="red", add=T)
labelLayer(x = sampling, txt="id", halo= TRUE,overlap=FALSE)

# Rajouter le cartouche, la légende, l'échelle, etc.
#Options : https://rdrr.io/cran/cartography/man/layoutLayer.html
layoutLayer(title = "Espace d'étude sur la baie d'Aytré, 25-02-2021",
            sources = "Source : UMR 7266 LIENSS",
            scale = FALSE, tabtitle = TRUE,
            frame = FALSE,theme = "blue.pal",
            north = TRUE)
```

### 3. Zoomer sur la zone à échantillonner (Aytré)

Calculer des bornes en coordonnées géographiques (longitude, latitude)
```{r, message=FALSE, warning=FALSE}
zzoom <- bbox(SpatialPoints(cbind(sampling$coord_x, sampling$coord_y)))
view(zzoom)
```


Prendre 10% de marge en hauteur et 15 % en largeur
```{r, message=FALSE, warning=FALSE}
deltax <- (zzoom[1,2]-zzoom[1,1])*0.15
deltay <- (zzoom[2,2]-zzoom[2,1])*0.1
```

Calcul des points extrêmes : st_point(x, y) avec x = longitude, y=latitude
```{r, message=FALSE, warning=FALSE}
sudouest <- st_point(c(zzoom[1,1]-deltax,zzoom[2,1]-deltay)) 
sudest <- st_point(c(zzoom[1,2]+deltax,zzoom[2,1]-deltay))
nordouest <- st_point(c(zzoom[1,1]-deltax,zzoom[2,2]+deltay))
nordest <- st_point(c(zzoom[1,2]+deltax,zzoom[2,2]+deltay))
```

Fabrique du polygone rectangle d'emprise
```{r, message=FALSE, warning=FALSE}
p1 <- rbind(sudouest, nordouest, nordest, sudest, sudouest)
pol <-st_polygon(list(p1))
zzoom_sf <- st_sfc(pol, crs=4326)
```

Découpe des autres géometries pour ne retenir que l'intersection avec ce rectangle
```{r, message=FALSE, warning=FALSE}
footprintz <- st_intersection(x = footprint, y = zzoom_sf)
cotez <- st_intersection(x = cote, y = zzoom_sf)
coteprecisez <- st_intersection(x = cote_precise, y = zzoom_sf)
drone_pathz <- st_intersection(x = drone_path, y = zzoom_sf)
```

Limiter les données à celles de la zone d'Aytré
```{r, message=FALSE, warning=FALSE}
datasfz <- st_intersection(x = datasf, y = zzoom_sf)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
dev.off()
```

```{r, message=FALSE, warning=FALSE}
par(mar = c(0.5,0,1.5,0), oma = c(0,1,0,1))
```

La carte basique avec les polygones, le cartouche, la légende, l'échelle, etc
Options : https://rdrr.io/cran/cartography/man/layoutLayer.html
```{r, message=FALSE, warning=FALSE, echo=FALSE}
plot(st_geometry(footprintz), col="lightblue", lwd=1)
plot(st_geometry(cotez), col="#93C572", add=T) ##vert
plot(st_geometry(coteprecisez), col="#006400", add=T) ##vert
plot(st_geometry(drone_pathz), col="black", add=T, lwd=2)
plot(st_geometry(sampling), col="red", add=T)
labelLayer(x = sampling, txt="id", halo= TRUE,overlap=FALSE)
layoutLayer(title = "Espace d'étude sur la baie d'Aytré, 25-02-2021",
            sources = "Source : UMR 7266 LIENSS",
            scale = FALSE, tabtitle = TRUE,
            frame = FALSE,theme = "blue.pal",
            north = TRUE)
```


### 4. Créer le template cartographique avec tmap

- [exemple !](https://github.com/riatelab/mexusaborder/blob/master/texmex.R)

```{r, message=FALSE, warning=FALSE, echo=FALSE}
dev.off()
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
library(tmap)
tmap_mode("plot") ##One option


basemap <- function(titlep = "") {
  par(mar = c(1,0,1.5,0), oma = c(2,7,0,7))
  
  map <- tm_shape(footprintz) +
    tm_borders() +
    tm_shape(coteprecisez) +
    tm_lines(col="#006400", lwd=2) + ##vert foncé
    tm_scale_bar(position = c(0.05,0.2)) +
    tm_compass(position = c(0.05,0.3)) +
    tm_layout(main.title = titlep, 
              main.title.size=0.7,
              title.bg.color="#59C7EB",
              legend.outside = TRUE)
  return (map)
}
```

Utiliser le template pour exporter en resolution 150 DPI la carte avec la trace du drone et les points d'échantillonage

```{r, message=FALSE, warning=FALSE, echo=TRUE}
sizes_aea <- getFigDim(x = zzoom_sf, mar = c(0,0,1.2,0), res = 150)
png("outputs/fig03.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map <- basemap("Zoom sur l'espace d'étude : la baie d'Aytré, \n 25-02-2021")
```

Voir ce template

```{r, message=FALSE, warning=FALSE, echo=TRUE}
map <- map+
  tm_shape(drone_pathz) +
  tm_lines(col="black") + #Trace du drone
  tm_shape(sampling) +
  tm_dots(col = "red", size=0.7)+ #Points d'échantillonage
  tm_text("id", size=0.7, auto.placement=TRUE, bg.color="white", bg.alpha=0.5, just=c(0,0)) 

map #Dessiner la carte dans le device (ici le fichier fig03.png)
dev.off() ## Fermer et sauver le fichier fig03.png

map #Voir la carte dans Plots

dev.off() ## Effacer les plots
```

## Analyser l'évolution des paramètres mesurés

### 1. evolution des paramètres


Le problème est que les unités de valeurs ne sont pas comparables
```{r, message=FALSE, warning=FALSE, echo=TRUE}
ggplot(data=datasfz, aes(x=local_time, y=property_value, colour=property_name)) +
  geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE)
```


Méthode : 

- On filtre sur les 4 variables d'intérêt
- Puis on regroupe par ces 4 variables (group_by) 
- Puis on calcule un nouvel indicateur 'ratio' sans unité, qui vaut 0 quand la variable est moyenne
- Puis on calcule un nouvel indicateur 'std' sans unité, qui vaut 0 quand la variable est moyenne mais dont l'écart est standardisé

```{r, message=FALSE, warning=FALSE, echo=TRUE}
subsetdatasf <- datasfz %>% 
  filter(property_name %in% c('turbidity_NTU', 'temp_C','salinity_ppt','chlorophyll_mg/L' ) ) %>%
  group_by(property_name) %>%
  mutate(ratio = -(1-(property_value/mean(property_value))))%>%
  mutate(std = (property_value-mean(property_value))/(sd(property_value)))
```

Seulement property_name est une variable factorielle, qui a gardé l'ensemble de ses 9 levels, même après le tri sur 4 variables
```{r, message=FALSE, warning=FALSE, echo=TRUE}
unique(subsetdatasf$property_name)
```

On reset donc les levels pour 4 niveaux (notez qu'on nomme "chlorophyll_mg/L" en "chlorophyll_RFU", c'est un abus...)
```{r, message=FALSE, warning=FALSE, echo=TRUE}
levels(subsetdatasf$property_name) <- list(temp_C="temp_C", turbidity_NTU="turbidity_NTU", chlorophyll_RFU="chlorophyll_mg/L", salinity_ppt="salinity_ppt")
```

#### 1.1 Evolution de la turbidité

Filtrer le dataset zoomé sur Aytré pour ne traiter que turbidity
Critère : property_name=='turbidity_NTU'

```{r, message=FALSE, warning=FALSE, echo=TRUE}
oneparam <- subsetdatasf %>% 
  filter(property_name=='turbidity_NTU') 

```

Résumé statistique rapide
```{r, message=FALSE, warning=FALSE, echo=TRUE}
summary(oneparam)
colnames(oneparam)
summary(oneparam$ratio)
hist(oneparam$ratio, main="Distribution de l'écart à la turbidté moyenne")
```

##### 1.1.1 turbidity dans le temps

```{r, message=FALSE, warning=FALSE, echo=TRUE}
g <- ggplot(oneparam , aes(x=local_time, y=property_value)) 
g <- g + geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE) 
g <- g + geom_hline(yintercept=mean(oneparam$property_value), linetype="dashed", color = "red")
g <- g + ggtitle("Evolution de la turbidité sur Aytré") # pour le titre principal
g <- g  + xlab("temps") # pour le titre de l'axe des x
g <- g  + ylab("Turbidity") # pour le titre de l'axe des y

g
#dev.copy(png,'./outputs/turbidity_zoom.png')
#dev.off()
```


##### 1.1.2 ratio dans le temps

```{r, message=FALSE, warning=FALSE, echo=FALSE}
g <- ggplot(oneparam , aes(x=local_time, y=ratio)) 
g <- g + geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE) 
g <- g + geom_hline(yintercept=0, linetype="dashed", color = "red")
g <- g + ggtitle("Evolution de la turbidité sur Aytré") # pour le titre principal
g <- g  + xlab("temps") # pour le titre de l'axe des x
g <- g  + ylab("Distance à la moyenne") # pour le titre de l'axe des y
g
#dev.copy(png,'./outputs/turbidity_ratio_zoom.png')
#dev.off()
```

##### 1.1.3 std dans le temps

```{r, message=FALSE, warning=FALSE, echo=FALSE}
g <- ggplot(oneparam , aes(x=local_time, y=std)) 
g <- g + geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE) 
g <- g + geom_hline(yintercept=0, linetype="dashed", color = "red")
g <- g + ggtitle("Evolution de la turbidité sur Aytré") # pour le titre principal
g <- g  + xlab("temps") # pour le titre de l'axe des x
g <- g  + ylab("Distance à la moyenne standardisée") # pour le titre de l'axe des y
g
#dev.copy(png,'./outputs/turbidity_std_zoom.png')
#dev.off()
```

##### 1.1.4 Carto de cette évolution 

- [exemple!](https://github.com/riatelab/mexusaborder/blob/master/texmex.R)
- [aide tmap!](https://bookdown.org/nicohahn/making_maps_with_r5/docs/tmap.html)

Appeler le fond de carte et déterminer la taille de la figure pour une résolution de 150 DPI
```{r, message=FALSE, warning=FALSE, echo=TRUE}
library(tmap)
dev.off()
map <- basemap("Espace d'étude : la baie d'Aytré, 25-02-2021")
tmap_mode("plot") ##One option
#tmap_mode("view") ##Or the other
sizes_aea <- getFigDim(x = zzoom_sf, mar = c(0,0,1.2,0), res = 150)
```

Choisir sa palette de couleur
```{r, message=FALSE, warning=FALSE, echo=TRUE}
# tmaptools::palette_explorer()
maPalette <- tmaptools::get_brewer_pal("RdYlBu", n = 4)
```

Carte de turbidité
```{r, message=FALSE, warning=FALSE, echo=TRUE}
#png("outputs/raw_turbidity_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(oneparam) +
  tm_dots(col = "property_value", 
        midpoint = median(oneparam$property_value),
        palette=rev(maPalette), 
        style="order") 
map_param
#dev.off()
```

Carte de std de turbidité
```{r, message=FALSE, warning=FALSE, echo=FALSE}
#png("outputs/turbidity_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(oneparam) +
  tm_dots(col = "std", 
          midpoint = median(oneparam$std), palette=rev(maPalette), style="order")

map_param
#dev.off()
```

#### 1.2 Refaire pour température, salinity, chlorophylle

Filtrer le dataset zoomé sur Aytré pour ne traiter que température
Critère : property_name=='temp_C'

```{r, message=FALSE, warning=FALSE, echo=TRUE}
oneparam <- subsetdatasf %>% 
  filter(property_name=='temp_C')

hist(oneparam$ratio)
```

Carte de température

```{r, message=FALSE, warning=FALSE, echo=FALSE}
#dev.off()
#png("outputs/temperature_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(oneparam) +
  tm_dots(col = "std", midpoint = median(oneparam$std), palette=rev(maPalette), style="order") 
map_param
#dev.off()
```

Filtrer le dataset zoomé sur Aytré pour ne traiter que salinité
Critère : property_name=='salinity_ppt'
```{r, message=FALSE, warning=FALSE, echo=TRUE}

oneparam <- subsetdatasf %>% 
  filter(property_name=='salinity_ppt')

hist(oneparam$ratio)
median(oneparam$ratio)
```

Carte de salinité
```{r, message=FALSE, warning=FALSE, echo=FALSE}
# dev.off()
# png("outputs/salinite_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(oneparam) +
  tm_dots(col = "std", midpoint = median(oneparam$std), palette=rev(maPalette), style="order") 
map_param
# dev.off()
```

Filtrer le dataset zoomé sur Aytré pour ne traiter que chlorophylle
Critère : property_name=='chlorophyll_RFU'
```{r, message=FALSE, warning=FALSE, echo=TRUE}
oneparam <- subsetdatasf %>% 
  filter(property_name=='chlorophyll_RFU')
hist(oneparam$ratio)
median(oneparam$ratio)
```

Carte de chlorophylle
```{r, message=FALSE, warning=FALSE, echo=FALSE}
#dev.off()
#png("outputs/chlorophylle_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(oneparam) +
  tm_dots(col = "std", midpoint = median(oneparam$std), palette=rev(maPalette), style="order") 
map_param
#dev.off()
```

#### 1.3 Superposer les courbes.


Afficher un graphique montrant l'évolution des 4 variables en fonction du temps
```{r, message=FALSE, warning=FALSE, echo=TRUE}
ggplot(data=subsetdatasf, aes(x=local_time, y=property_value, colour=property_name, linetype=property_name)) +
  geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE)+
  ggtitle("Evolution de 4 paramètres sur la baie d'Aytré")+ # pour le titre principal
  xlab("temps")+# Légende axe des abscisses 
  ylab("Mesures (différents unités)") # pour le titre de l'axe des y
#dev.copy(png,'./outputs/raw_4courbes_Aytré.png')
#dev.off()
```

Afficher un graphique montrant l'évolution des 4 variables standardisées en fonction du temps
```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(data=subsetdatasf, aes(x=local_time, y=std, colour=property_name, linetype=property_name)) +
  geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE)+
  geom_hline(yintercept=0, linetype="dashed", color = "red")+
  ggtitle("Evolution de 4 paramètres sur la baie d'Aytré")+ # pour le titre principal
  xlab("temps")+# Légende axe des abscisses 
  ylab("Ecart standardisé à la moyenne") # pour le titre de l'axe des y
#dev.copy(png,'./outputs/4courbes_Aytré_standard.png')
#dev.off()
```


## calculer la distance à la côte

- [aide !](https://gis.stackexchange.com/questions/243994/how-to-calculate-distance-from-point-to-linestring-in-r-using-sf-library-and-g)

```{r, message=FALSE, warning=FALSE, echo=TRUE}
colnames(coteprecisez)

colnames(datasfz)
```

Ne pas exécuter ce chunk de code, mais comprendre : 
```{r, message=FALSE, warning=FALSE, echo=TRUE}
distances <- st_distance(x = datasfz, y = coteprecisez)
#Pourquoi cette sortie est fausse (expliquez à partir de la lecture de la documentation de st_distance)
rm(distances) 
```

Solution
```{r, message=FALSE, warning=FALSE, echo=TRUE}

one_singleline <- st_multilinestring(st_geometry(coteprecisez))
one_singleline <- st_sfc(one_singleline)
one_singleline <- st_set_crs(x = one_singleline, value = 4326)

distancesCote <- st_distance(x = subsetdatasf, y = one_singleline)
```

Distribution des distances à la côte calculées
```{r, message=FALSE, warning=FALSE, echo=TRUE}
hist(distancesCote)
#dev.copy(png,'./outputs/histogramme_distance_cote.png')
#dev.off()
```


Ajouter la distance comme nouvelle variable au jeu de données
```{r, message=FALSE, warning=FALSE, echo=TRUE}
subsetdatasf <- cbind(subsetdatasf, distance = as.numeric(distancesCote))
```


Faire une carte de l'évolution de la distance à la cote
```{r, message=FALSE, warning=FALSE, echo=TRUE}
#dev.off()
#png("outputs/distancecote_map_zoom.png", width = sizes_aea[1], height = sizes_aea[2], res = 150)
map_param <- map + 
  tm_shape(subsetdatasf) +
  tm_dots(col = "distance", midpoint = median(subsetdatasf$distance), palette=rev(maPalette), style="order") 
map_param
#dev.off()
```

### calculer la corrélation entre turbidité et distance à la cote

```{r, message=FALSE, warning=FALSE, echo=TRUE}
oneparam <- subsetdatasf %>% 
  filter(property_name=='turbidity_NTU') 
```

Calcul de la corrélation
```{r, message=FALSE, warning=FALSE, echo=TRUE}
Mat<-st_drop_geometry(oneparam[,c("property_value", "distance")])
round(cor(Mat), 2)
```

testez aussi avec "ratio", "std"

```{r, message=FALSE, warning=FALSE, echo=TRUE}
library(corrplot)
corrplot(cor(Mat),method="number")
#dev.copy(png,'./outputs/corr_distance_cote_turbidite.png')
#dev.off()

library (Hmisc)
rescorr<-rcorr(as.matrix(Mat))
MatCor<-rescorr$r
MatCor
```


Afficher un graphique montrant l'évolution des 4 variables standardisées avec la distance standardisée à la côte en fonction du temps
```{r, message=FALSE, warning=FALSE, echo=TRUE}

par(mar = c(1,1,1,1), oma = c(1,1,1,1))

ggplot(data=subsetdatasf, aes(x=local_time, y=std, colour=property_name, linetype=property_name)) +
  geom_hline(yintercept=0, linetype="dashed", color = "red")+
  geom_smooth(aes(y=(distance-mean(distance))/sd(distance)), color="#006400", method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE)+
  geom_smooth(method = 'loess', formula = 'y ~ x', span = 0.1, se=FALSE)+
  ggtitle("Evolution de 4 paramètres sur la baie d'Aytré, \n avec la distance standardisée à la côte")+ # pour le titre principal
  xlab("temps")+# Légende axe des abscisses 
  ylab("Ecart standardisé à la moyenne") # pour le titre de l'axe des y

#dev.copy(png,'./outputs/5courbes_Aytré_standard.png')
#dev.off()
```

### regression linéaire entre distance à la cote et turbidité



```{r, message=FALSE, warning=FALSE, echo=TRUE}

model<-lm(property_value~distance,data=oneparam)
summary(model)
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
library("texreg")
screenreg (model, ci.force = TRUE)
```

commenter

Recalculer la valeur de pente a du modèle à la main : 
turbidity = a * distance + b
La valeur de turbidity est données par property_value dans notre cas

```{r, message=FALSE, warning=FALSE, echo=TRUE}
a <- cor(oneparam$property_value, oneparam$distance) * sd(oneparam$property_value)  / sd(oneparam$distance)
# a = -0.04150674 ok
b <- mean(oneparam$property_value) - a * mean(oneparam$distance) # 44.74173 ok
r <- cov(oneparam$property_value, oneparam$distance)/(sd(oneparam$property_value)*sd(oneparam$distance)) #-0.3769931
```

#### figures de la régression

Modèle
```{r, message=FALSE, warning=FALSE, echo=TRUE}
ggplot(data = oneparam,
       mapping = aes(x = distance, y=property_value)) + 
  geom_point(cex=0.5)+
  labs(x = "Distance à la côte en mètres",
       y = "Valeur de turbidité",
       title = "Relation entre la turbidité et l'éloignement à la côte",
       subtitle = "La forme de la relation est-elle linéaire ?",
       caption = "Source : master 2 CNRS, projet drone, LIENSS")
#dev.copy(png,'./outputs/plot_model_regression.png')
#dev.off()
```

Résidus
```{r, message=FALSE, warning=FALSE, echo=TRUE}
ggplot(data = oneparam,
       mapping = aes(x = distance, y=scale(model$residuals))) + 
  geom_point(cex=0.5)+
  labs(x = "Distance à la côte en mètres",
       y = "Résidus normalisés par rapport à la distance",
       title = "Résidus de la régression entre la turbidité et l'éloignement à la côte",
       subtitle = "les résidus sont-ils homogènes ?",
       caption = "Source : master 2 CNRS, projet drone, LIENSS")
#dev.copy(png,'./outputs/plot_model_residus.png')
#dev.off()
```

